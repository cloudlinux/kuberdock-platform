import string

from ..core import ExclusiveLockContextManager, db
from ..domains.models import PodDomain, BaseDomain
from ..exceptions import (
    DomainNotFound,
    InternalAPIError,
    PodDomainExists,
    PublicAccessAssigningError,
)
from ..settings import PUBLIC_ACCESS_ASSIGNING_TIMEOUT
from ..utils import domainize, randstr


def set_pod_domain(pod, domain_name):
    """
    Generate new or return existing domain name for IP sharing
    New domain name will be generated as
    <domainized username>-<domainized pod name>
    If that name already exists, then will be appended some random suffix to
    it.

    :param pod: Pod object
    :type pod: kubedock.pods.models.Pod
    :param domain_name: Domain name, can be Base Domain or Full Domain
     Base Domain -- subdomain part will be autogenerated from Pod Name,
      e.g. specifying 'base.domain.name' will cause
      'user-podname.base.domain.name' to set as Pod Domain
     Full Domain -- KD will try to set exact Domain Name to Pod,
      e.g. specifying 'mypod.base.domain.name' will cause attempt
      to create Pod Domain with provided Domain Name ('base.domain.name'
      should exists in hoster added Domains and 'mypod' should be free
      in this domain zone)
    :type domain_name: string
    :return: instance of PodDomain model
    :rtype: kubedock.domains.models.PodDomain

    """
    with ExclusiveLockContextManager(
            'kapi.pod_domains.set_pod_domain',
            blocking=True,
            ttl=PUBLIC_ACCESS_ASSIGNING_TIMEOUT) as lock:
        if not lock:
            raise PublicAccessAssigningError(details={
                'message': 'Timeout getting Pod Domain'
            })

        base_domain = BaseDomain.query.filter_by(name=domain_name).first()

        if base_domain:
            pod_domain, sub_domain_part = _autogen_subdomain(pod, base_domain)
        else:
            pod_domain, sub_domain_part, base_domain = \
                _exact_subdomain(pod, domain_name)

        if pod_domain is None:
            pod_domain = PodDomain(name=sub_domain_part,
                                   base_domain=base_domain,
                                   pod_id=pod.id)
            db.session.add(pod_domain)
            db.session.commit()

        return pod_domain


def _autogen_subdomain(pod, base_domain):
    """
    Generate Subdomain from Pod name or Pod Domain if Pod already has it

    :param pod: Pod instance
    :param base_domain: BaseDomain instance in which zone Subdomain should be
     placed
    :return: (pod_domain, sub_domain_part):
     pod_domain -- if Pod Domain already exists for specified pod, else None
     sub_domain_part -- autogenerated Subdomain part

    """
    pod_domain = PodDomain.query.filter_by(domain_id=base_domain.id,
                                           pod_id=pod.id).first()
    if pod_domain:
        return pod_domain, None

    pod_name = domainize(pod.name)
    if not pod_name:
        pod_name = randstr(symbols=string.lowercase + string.digits,
                           length=8)
    user = domainize(pod.owner.username)
    sub_domain_part = '{0}-{1}'.format(user, pod_name)
    sub_domain_part = _get_unique_domain_name(sub_domain_part, base_domain.id)
    if sub_domain_part is None:
        raise InternalAPIError('Failed to get unique pod domain name')

    return None, sub_domain_part


def _exact_subdomain(pod, domain_name):
    """
    Get exact Subdomain part if it availabe or Pod Domain if Pod already has it
    :param pod: Pod instance
    :param domain_name: Full Domain name to be used as Pod Domain
    :return: (pod_domain, sub_domain_part, base_domain):
     pod_domain -- if Pod Domain already exists for specified pod, else None.
      Editing Pod Domain possible -- just specify domain_name as new Pod Domain
     sub_domain_part -- Subdomain part of Full Domain
     base_domain -- BaseDomain instance for specified Full Domain

    """
    sub_domain_part, base_domain_part = domain_name.split('.', 1)

    base_domain = BaseDomain.query.filter_by(name=base_domain_part).first()
    if base_domain is None:
        raise DomainNotFound(
            "Can't find BaseDomain for requested domain {0}".format(
                domain_name
            )
        )
    if PodDomain.query.filter_by(name=sub_domain_part,
                                 domain_id=base_domain.id).first():
        raise PodDomainExists()
    pod_domain = PodDomain.query.filter_by(domain_id=base_domain.id,
                                           pod_id=pod.id).first()
    if pod_domain:
        pod_domain.name = sub_domain_part
        return pod_domain, None, None

    return None, sub_domain_part, base_domain


def _get_unique_domain_name(basename, domain_id):
    """Returns unique domain name for given basename.
    If basename does not exists in DB with specified domain_id, then it will
    be returned as is.
    Otherwise will be returned basename with random suffix
    """
    pod_domain = PodDomain.query.filter_by(name=basename,
                                           domain_id=domain_id).first()
    if pod_domain is None:
        return basename

    res = None
    # try to get unique random domain name. If it fails for tries limit,
    # then something is going wrong, return None and it will be better to fail
    # in calling code
    tries_limit = 100
    random_suffix_length = 6
    for _ in xrange(tries_limit):
        suffix = randstr(
            symbols=string.lowercase + string.digits,
            length=random_suffix_length)
        new_name = '{0}{1}'.format(basename, suffix)
        pod_domain = PodDomain.query.filter_by(
            name=new_name, domain_id=domain_id).first()
        if pod_domain is None:
            res = new_name
            break
    return res
